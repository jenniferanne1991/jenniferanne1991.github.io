---
layout: post
current: post
cover:  assets/images/squares.jpg
navigation: True
title: Sum of Squares
date: 2019-09-21 10:15:00
tags: [python, maths]
class: post-template
subclass: 'post tag-python tag-maths'
---

Today I was working on [Sum of Squares](https://projecteuler.net/problem=273), one of the problems on [Project Euler](https://projecteuler.net). This problem is quite maths-heavy, and led me to research a few concepts such as [Fermat's $4n+1$ Theorem](http://mathworld.wolfram.com/Fermats4nPlus1Theorem.html) and the [Sum of Squares function](http://mathworld.wolfram.com/SumofSquaresFunction.html). The code itself, written in Python, utilised recursive functions to find an efficient solution.

The problem states the following:

> Consider equations of the form: $a^2 + b^2 = N$, $0 \leq a \leq b$, $a$, $b$ and $N$ integer.
>
> For $N$=65 there are two solutions:
>
> $a$=1, $b$=8 and $a$=4, $b$=7.
>
> We call $S(N)$ the sum of the values of $a$ of all solutions of $a^2 + b^2 = N$, $0 \leq a \leq b$, $a$, $b$ and $N$ integer.
>
> Thus $S(65)$ = 1 + 4 = 5.
>
> Find $\sum S(N)$, for all squarefree $N$ only divisible by primes of the form 4$k$+1 with 4$k$+1 < 150.

Decomposing this problem into its component parts, there are a few things we need:

1. All primes of the form 4$k$+1, with 4$k$+1<150.
2. A way to find all squarefree $N$ that are only divisible by these primes.
3. An efficient way to calculate $S(N)$ for each of the squarefree $N$.

We begin with step 1. Since the maximum is 150, it is easy to find all required primes using the same function as in my [Project Euler post]({% post_url 2019-09-18-project-euler %}):

```python
def is_prime(n):
	for i in range(2, int(math.sqrt(n)+1)):
		if n%i == 0:
			return False
	return True
```

Note that we have added 1 to ```math.sqrt(n)``` because ```range()``` excludes the upper bound. Now, to find all primes of the form 4$k$+1, we use ```is_prime(n)``` to test numbers that are congruent to 1 modulo 4. Since 1 is not prime, we can start with 5 and check every fourth number for primality until we reach the maximum (150 in our case):

```python
def one_mod_four_primes(maximum):
	current = 5
	ans = []
	while current < maximum:
		if is_prime(current):
			ans.append(current)
		current = current + 4
	return ans
```

We have therefore completed part 1 of our overall goal. One way to solve the problem from here is to take the primes we have found and use them to generate squarefree numbers. That is, we want to find every combination generated by multiplying one or more of our primes, but never the same prime twice. An example using the first few primes is shown below.
![Tree diagram](assets/images/problem_273_tree.png)
To generate this list of numbers, let ```factors``` be our list of primes. Then we can use the function below to obtain our list:

```python
def squarefree_numbers(factors):
	if len(factors) == 0:
		return []
	first = factors[0]
	ans = [first]
	factors.pop(0)
	temp = squarefree_numbers(factors)
	ans.extend(temp)
	ans.extend([i*first for i in temp])
	return ans
```

We could then brute force our way through the problem of calculating $\sum S(N)$ for all numbers in our list. The problem is,  